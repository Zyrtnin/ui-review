<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UI Review</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3344;
    --text: #e2e4ea;
    --text-dim: #8b8fa3;
    --accent: #6c8cff;
    --accent-hover: #8ba4ff;
    --critical: #ff4d6a;
    --critical-bg: rgba(255,77,106,0.12);
    --warning: #ffaa2c;
    --warning-bg: rgba(255,170,44,0.12);
    --suggestion: #4db8ff;
    --suggestion-bg: rgba(77,184,255,0.12);
    --success: #3ddc84;
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --mono: 'SF Mono', SFMono-Regular, Consolas, monospace;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: var(--font); background: var(--bg); color: var(--text); line-height: 1.5; }

  .container { max-width: 960px; margin: 0 auto; padding: 20px; }

  header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
  header h1 { font-size: 20px; font-weight: 600; }
  header .status { margin-left: auto; font-size: 13px; color: var(--text-dim); }
  header .status.ok { color: var(--success); }
  header .status.fail { color: var(--critical); }

  .panel { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
  .panel h2 { font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-dim); margin-bottom: 12px; }

  /* Environment */
  .env-bar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
  .env-btn { padding: 6px 14px; border: 1px solid var(--border); border-radius: 6px; background: var(--surface2); color: var(--text); cursor: pointer; font-size: 13px; transition: all 0.15s; position: relative; }
  .env-btn:hover { border-color: var(--accent); }
  .env-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
  .env-btn .remove-env { display: none; position: absolute; top: -6px; right: -6px; width: 16px; height: 16px; border-radius: 50%; background: var(--critical); color: #fff; border: none; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; }
  .env-btn:hover .remove-env { display: block; }
  .env-add-btn { padding: 6px 10px; border: 1px dashed var(--border); border-radius: 6px; background: transparent; color: var(--text-dim); cursor: pointer; font-size: 13px; }
  .env-add-btn:hover { border-color: var(--accent); color: var(--accent); }
  .url-input { flex: 1; min-width: 200px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--surface2); color: var(--text); font-size: 13px; font-family: var(--mono); }
  .url-input:focus { outline: none; border-color: var(--accent); }

  /* Pages */
  .pages-toolbar { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
  .pages-toolbar input[type="text"] { flex: 1; min-width: 150px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--surface2); color: var(--text); font-size: 13px; }
  .pages-toolbar input[type="text"]:focus { outline: none; border-color: var(--accent); }
  .discover-btn { padding: 6px 14px; border: 1px solid var(--accent); border-radius: 6px; background: transparent; color: var(--accent); cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s; white-space: nowrap; }
  .discover-btn:hover { background: rgba(108,140,255,0.1); }
  .discover-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .page-cap { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-dim); white-space: nowrap; }
  .page-cap select { padding: 4px 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); font-size: 12px; }
  .discover-status { font-size: 12px; color: var(--text-dim); padding: 4px 0; }
  .select-controls { display: flex; gap: 12px; margin-bottom: 8px; font-size: 13px; align-items: center; flex-wrap: wrap; }
  .select-controls a { color: var(--accent); cursor: pointer; text-decoration: none; }
  .select-controls a:hover { text-decoration: underline; }
  .select-controls .page-count { margin-left: auto; color: var(--text-dim); font-size: 12px; }
  .status-filter { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-dim); }
  .status-filter select { padding: 3px 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); font-size: 12px; }
  .page-tree { max-height: 400px; overflow-y: auto; }
  .page-group { margin-bottom: 2px; }
  .page-group-header { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 13px; font-weight: 500; color: var(--text); user-select: none; }
  .page-group-header:hover { color: var(--accent); }
  .page-group-header .arrow { font-size: 10px; color: var(--text-dim); transition: transform 0.15s; width: 12px; text-align: center; }
  .page-group-header .arrow.open { transform: rotate(90deg); }
  .page-group-header .group-count { font-size: 11px; color: var(--text-dim); font-weight: 400; }
  .page-group-items { display: none; padding-left: 20px; }
  .page-group-items.open { display: block; }
  .page-item { font-size: 13px; padding: 3px 0; }
  .page-item-row { display: flex; align-items: center; gap: 6px; }
  .page-item input[type="checkbox"] { accent-color: var(--accent); }
  .page-item .path { color: var(--text-dim); font-family: var(--mono); font-size: 11px; }
  .page-item .status-code { font-size: 10px; padding: 0 4px; border-radius: 3px; font-family: var(--mono); }
  .page-item .status-code.ok { color: var(--success); background: rgba(61,220,132,0.1); }
  .page-item .status-code.redirect { color: var(--warning); background: var(--warning-bg); }
  .page-item .status-code.error { color: var(--critical); background: var(--critical-bg); }
  .page-item.hidden { display: none; }
  .page-item.ungrouped { padding-left: 20px; }
  .page-item .actions-toggle { font-size: 10px; color: var(--accent); cursor: pointer; margin-left: auto; text-decoration: none; }
  .page-item .actions-toggle:hover { text-decoration: underline; }
  .page-item .actions-badge { font-size: 10px; padding: 0 4px; border-radius: 3px; background: rgba(108,140,255,0.15); color: var(--accent); }
  .actions-editor { display: none; margin: 4px 0 4px 22px; padding: 8px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; }
  .actions-editor.open { display: block; }
  .actions-editor label { font-size: 12px; color: var(--text-dim); display: block; margin-bottom: 4px; }
  .actions-editor textarea { width: 100%; min-height: 60px; padding: 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 11px; font-family: var(--mono); resize: vertical; box-sizing: border-box; }
  .actions-editor .actions-hint { font-size: 10px; color: var(--text-dim); margin-top: 4px; }
  .actions-editor .actions-error { font-size: 10px; color: var(--critical); margin-top: 2px; }
  .custom-page { margin-top: 8px; display: flex; gap: 8px; }
  .custom-page input { flex: 1; padding: 5px 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); font-size: 12px; font-family: var(--mono); }
  .custom-page button { padding: 5px 12px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); cursor: pointer; font-size: 12px; }

  /* Auth */
  .auth-toggle { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; color: var(--text-dim); user-select: none; }
  .auth-toggle:hover { color: var(--text); }
  .auth-toggle .arrow { font-size: 10px; transition: transform 0.15s; }
  .auth-toggle .arrow.open { transform: rotate(90deg); }
  .auth-body { display: none; margin-top: 12px; }
  .auth-body.open { display: block; }
  .auth-form { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; font-size: 13px; max-width: 500px; }
  .auth-form label { color: var(--text-dim); text-align: right; }
  .auth-form input[type="text"], .auth-form input[type="password"] { padding: 6px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); font-size: 13px; font-family: var(--mono); }
  .auth-form input:focus { outline: none; border-color: var(--accent); }
  .auth-divider { grid-column: 1 / -1; text-align: center; color: var(--text-dim); font-size: 12px; padding: 4px 0; }
  .auth-actions { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
  .auth-test-btn { padding: 6px 14px; border: 1px solid var(--accent); border-radius: 6px; background: transparent; color: var(--accent); cursor: pointer; font-size: 13px; transition: all 0.15s; }
  .auth-test-btn:hover { background: rgba(108,140,255,0.1); }
  .auth-test-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .auth-clear-btn { padding: 6px 14px; border: 1px solid var(--border); border-radius: 6px; background: transparent; color: var(--text-dim); cursor: pointer; font-size: 13px; }
  .auth-status { font-size: 12px; }
  .auth-status.ok { color: var(--success); }
  .auth-status.fail { color: var(--critical); }
  .auth-upload { grid-column: 1 / -1; }
  .auth-upload input[type="file"] { font-size: 12px; color: var(--text-dim); }

  /* Viewports */
  .viewport-bar { display: flex; gap: 12px; flex-wrap: wrap; }
  .vp-item { display: flex; align-items: center; gap: 6px; font-size: 13px; }
  .vp-item input[type="checkbox"] { accent-color: var(--accent); }
  .vp-dims { color: var(--text-dim); font-size: 11px; }

  /* Actions */
  .actions { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 16px; }
  .run-btn { padding: 10px 28px; border: none; border-radius: 8px; background: var(--accent); color: #fff; font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.15s; }
  .run-btn:hover { background: var(--accent-hover); }
  .run-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .resume-btn { padding: 10px 20px; border: 1px solid var(--accent); border-radius: 8px; background: transparent; color: var(--accent); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.15s; }
  .resume-btn:hover { background: rgba(108,140,255,0.1); }
  .resume-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .pause-btn { padding: 10px 20px; border: 1px solid var(--warning); border-radius: 8px; background: transparent; color: var(--warning); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.15s; }
  .pause-btn:hover { background: var(--warning-bg); }
  .stop-btn { padding: 10px 20px; border: 1px solid var(--critical); border-radius: 8px; background: transparent; color: var(--critical); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.15s; }
  .stop-btn:hover { background: var(--critical-bg); }
  .export-btn { padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.15s; }
  .export-btn:hover { border-color: var(--accent); color: var(--accent); }
  .export-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .allow-private { display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text-dim); }
  .allow-private input { accent-color: var(--accent); }

  /* Report info bar */
  .report-info { font-size: 12px; color: var(--text-dim); margin-bottom: 12px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .report-info .report-id { font-family: var(--mono); }
  .report-info .report-status { padding: 1px 6px; border-radius: 4px; font-weight: 500; }
  .report-info .report-status.complete { background: rgba(61,220,132,0.15); color: var(--success); }
  .report-info .report-status.running { background: rgba(108,140,255,0.15); color: var(--accent); }
  .report-info .report-status.interrupted { background: var(--warning-bg); color: var(--warning); }
  .report-info .report-status.error { background: var(--critical-bg); color: var(--critical); }
  .report-history { font-size: 12px; color: var(--accent); cursor: pointer; text-decoration: none; margin-left: auto; }
  .report-history:hover { text-decoration: underline; }

  /* History dropdown */
  .history-panel { display: none; margin-bottom: 16px; }
  .history-panel.open { display: block; }
  .history-item { display: flex; align-items: center; gap: 12px; padding: 8px 12px; border-bottom: 1px solid var(--border); font-size: 13px; cursor: pointer; }
  .history-item:hover { background: rgba(255,255,255,0.03); }
  .history-item .hi-date { color: var(--text-dim); font-size: 12px; min-width: 140px; }
  .history-item .hi-url { font-family: var(--mono); font-size: 12px; color: var(--text-dim); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .history-item .hi-progress { font-size: 12px; }

  /* Progress */
  .progress { font-size: 13px; color: var(--text-dim); margin-bottom: 16px; min-height: 20px; }
  .progress .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 6px; vertical-align: middle; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Results */
  .results-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
  .results-header h2 { margin-bottom: 0; }
  .summary-badges { display: flex; gap: 8px; flex-wrap: wrap; }
  .badge { padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: 600; }
  .badge.critical { background: var(--critical-bg); color: var(--critical); }
  .badge.warning { background: var(--warning-bg); color: var(--warning); }
  .badge.suggestion { background: var(--suggestion-bg); color: var(--suggestion); }

  .result-card { background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 12px; overflow: hidden; }
  .result-card.cached { opacity: 0.7; }
  .result-card-header { padding: 12px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 500; }
  .result-card-header:hover { background: rgba(255,255,255,0.03); }
  .result-card-header .arrow { font-size: 11px; color: var(--text-dim); transition: transform 0.15s; }
  .result-card-header .arrow.open { transform: rotate(90deg); }
  .result-card-header .page-name { flex: 1; }
  .result-card-header .issue-count { font-size: 12px; color: var(--text-dim); }
  .cached-tag { font-size: 10px; color: var(--text-dim); background: var(--surface); padding: 1px 6px; border-radius: 3px; }

  .result-card-body { display: none; padding: 0 16px 12px; }
  .result-card-body.open { display: block; }
  .result-card-content { display: flex; gap: 16px; }
  .screenshot-panel { flex: 0 0 40%; max-width: 400px; }
  .screenshot-panel img { width: 100%; border-radius: 4px; cursor: zoom-in; border: 1px solid var(--border); }
  .screenshot-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); z-index: 100; cursor: zoom-out; justify-content: center; align-items: center; }
  .screenshot-overlay.open { display: flex; }
  .screenshot-overlay img { max-width: 95vw; max-height: 95vh; object-fit: contain; }
  .issues-panel { flex: 1; min-width: 0; }
  .result-card .summary-text { font-size: 13px; color: var(--text-dim); margin-bottom: 10px; font-style: italic; }

  .issue { padding: 10px 0; border-top: 1px solid var(--border); }
  .issue:first-child { border-top: none; }
  .issue-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
  .issue .category { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.3px; }
  .issue .location { font-size: 12px; color: var(--text-dim); margin-bottom: 2px; }
  .issue .description { font-size: 13px; }
  .issue .recommendation { font-size: 12px; color: var(--accent); margin-top: 4px; }

  .error-card { background: var(--critical-bg); border: 1px solid var(--critical); border-radius: 8px; padding: 12px 16px; margin-bottom: 12px; font-size: 13px; color: var(--critical); }

  /* Watch mode controls */
  .watch-panel { background: var(--surface); border: 1px solid var(--accent); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
  .watch-panel .watch-status { font-size: 13px; font-weight: 500; color: var(--accent); display: flex; align-items: center; gap: 6px; }
  .watch-panel .watch-status .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); animation: pulse 2s ease-in-out infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .watch-panel .rerun-btn { padding: 6px 16px; border: 1px solid var(--accent); border-radius: 6px; background: transparent; color: var(--accent); cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s; }
  .watch-panel .rerun-btn:hover { background: rgba(108,140,255,0.1); }
  .watch-panel .rerun-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .watch-panel .stop-watch-btn { padding: 6px 16px; border: 1px solid var(--critical); border-radius: 6px; background: transparent; color: var(--critical); cursor: pointer; font-size: 13px; transition: all 0.15s; }
  .watch-panel .stop-watch-btn:hover { background: var(--critical-bg); }
  .watch-panel .poll-control { display: flex; align-items: center; gap: 6px; margin-left: auto; font-size: 12px; color: var(--text-dim); }
  .watch-panel .poll-control select { padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface2); color: var(--text); font-size: 12px; }

  .empty { text-align: center; color: var(--text-dim); padding: 40px; font-size: 14px; }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>UI Review</h1>
    <div class="status" id="ollamaStatus">Checking Ollama...</div>
  </header>

  <!-- Environment -->
  <div class="panel">
    <h2>Environment</h2>
    <div class="env-bar" id="envBar">
      <!-- Dynamic env buttons rendered by JS -->
      <input type="text" class="url-input" id="baseUrl" value="http://localhost:8081" placeholder="https://your-app.com">
    </div>
  </div>

  <!-- Pages -->
  <div class="panel">
    <h2>Pages</h2>
    <div class="pages-toolbar">
      <input type="text" id="pageSearch" placeholder="Search pages...">
      <button class="discover-btn" id="discoverBtn">Discover Pages</button>
      <div class="page-cap">
        <label for="pageCap">Cap:</label>
        <select id="pageCap">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="200">200</option>
        </select>
      </div>
    </div>
    <div class="discover-status" id="discoverStatus"></div>
    <div class="select-controls">
      <a id="selectAll">Select all</a>
      <a id="selectNone">Select none</a>
      <div class="status-filter">
        <label for="statusFilter">Status:</label>
        <select id="statusFilter">
          <option value="all" selected>All</option>
          <option value="ok">2xx OK</option>
          <option value="non-error">2xx + 3xx</option>
          <option value="error">4xx/5xx only</option>
        </select>
      </div>
      <span class="page-count" id="pageCount"></span>
    </div>
    <div class="page-tree" id="pageTree"></div>
    <div class="custom-page">
      <input type="text" id="customPath" placeholder="/custom-page.html">
      <button id="addCustom">Add</button>
    </div>
  </div>

  <!-- Authentication -->
  <div class="panel">
    <div class="auth-toggle" id="authToggle">
      <span class="arrow" id="authArrow">&#9654;</span>
      <h2 style="margin:0">Authentication (optional)</h2>
      <span class="auth-status" id="authIndicator"></span>
    </div>
    <div class="auth-body" id="authBody">
      <div class="auth-form">
        <label for="loginUrl">Login URL:</label>
        <input type="text" id="loginUrl" placeholder="/login.php" value="/login.php">
        <label for="authUser">Username:</label>
        <input type="text" id="authUser" placeholder="admin">
        <label for="authPass">Password:</label>
        <input type="password" id="authPass" placeholder="password">
        <div class="auth-divider">— or upload storageState —</div>
        <div class="auth-upload">
          <input type="file" id="storageStateFile" accept=".json">
        </div>
      </div>
      <div class="auth-actions">
        <button class="auth-test-btn" id="authTestBtn">Test Login</button>
        <button class="auth-clear-btn" id="authClearBtn">Clear Auth</button>
        <span class="auth-status" id="authStatus"></span>
      </div>
    </div>
  </div>

  <!-- Viewports -->
  <div class="panel">
    <h2>Viewports</h2>
    <div class="viewport-bar" id="viewportBar"></div>
  </div>

  <!-- Actions -->
  <div class="actions">
    <button class="run-btn" id="runBtn">Run Review</button>
    <button class="pause-btn" id="pauseBtn" style="display:none">Pause</button>
    <button class="stop-btn" id="stopBtn" style="display:none">Stop</button>
    <button class="resume-btn" id="resumeBtn" style="display:none">Resume</button>
    <button class="export-btn" id="exportBtn" style="display:none">Export Report</button>
    <label class="allow-private">
      <input type="checkbox" id="allowPrivate" checked> Allow private IPs
    </label>
    <label class="allow-private">
      <input type="checkbox" id="watchMode"> Watch mode
    </label>
  </div>

  <!-- Report info -->
  <div class="report-info" id="reportInfo" style="display:none">
    <span class="report-id" id="reportId"></span>
    <span class="report-status" id="reportStatus"></span>
    <span id="reportProgress"></span>
    <span id="reportTime"></span>
    <a class="report-history" id="historyToggle">History</a>
  </div>

  <!-- History -->
  <div class="panel history-panel" id="historyPanel">
    <h2>Past Reports</h2>
    <div id="historyList"></div>
  </div>

  <div class="progress" id="progress"></div>

  <!-- Watch mode controls (hidden until watch-ready) -->
  <div class="watch-panel" id="watchPanel" style="display:none">
    <span class="watch-status"><span class="dot"></span> Watching</span>
    <button class="rerun-btn" id="rerunBtn">Re-review</button>
    <button class="stop-watch-btn" id="stopWatchBtn">Stop Watching</button>
    <span class="poll-control">
      Poll:
      <select id="pollSelect">
        <option value="0">Off</option>
        <option value="60000">1 min</option>
        <option value="300000" selected>5 min</option>
        <option value="900000">15 min</option>
        <option value="1800000">30 min</option>
      </select>
    </span>
  </div>

  <!-- Results -->
  <div id="results"></div>
</div>

<!-- Screenshot zoom overlay -->
<div class="screenshot-overlay" id="screenshotOverlay" onclick="this.classList.remove('open'); document.body.style.overflow = '';">
  <img id="screenshotOverlayImg" src="" alt="Screenshot zoom">
</div>

<script>
const DEFAULT_PAGES = [
  { name: 'Home', path: '/' },
  { name: 'Login', path: '/login.php' },
  { name: 'Player Portal', path: '/player_portal.html' },
  { name: 'Dashboard', path: '/player_dashboard.php' },
  { name: 'Player Profile', path: '/player_profile.html' },
  { name: 'Submit Score', path: '/player_submit.html' },
  { name: 'Tournament Entry', path: '/tournament_entry.html' },
  { name: 'Leaderboard', path: '/tournament_leaderboard.html' },
  { name: 'Archive', path: '/tournament_archive.html' },
  { name: 'Game Leaderboards', path: '/game_leaderboards.html' },
  { name: 'Global Rankings', path: '/global_rankings.html' },
];

const VIEWPORTS = {
  desktop: { width: 1920, height: 1080 },
  laptop: { width: 1366, height: 768 },
  tablet: { width: 768, height: 1024 },
  mobile: { width: 375, height: 812 },
};

const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

const STORAGE_KEY_ENVS = 'ui-review-environments';

// Current report state
let currentReportId = null;
let currentResults = {};  // key → result data
let currentReviewController = null;  // AbortController for active review
let reviewWasPaused = false;  // distinguishes pause from stop
let currentWatchReportId = null;  // active watch session report ID

// Per-page actions storage: path → actions array
const pageActions = new Map();

// --- Cleanup on Tab Close ---
// Cancel any active review when the tab is closed/navigated away.
// This immediately signals the server to abort in-flight Ollama requests
// and release GPU resources.
window.addEventListener('beforeunload', () => {
  if (currentReviewController) {
    currentReviewController.abort();
  }
});

// pagehide fires when the page is navigated away, closed, or backgrounded.
// More reliable than beforeunload in some browsers.
window.addEventListener('pagehide', () => {
  if (currentReviewController) {
    currentReviewController.abort();
  }
});

// --- Init ---
async function init() {
  renderPageTree();
  renderViewports();
  await renderEnvironments();
  setupActions();
  checkHealth();
  $('#progress').innerHTML = '<span class="spinner"></span> Loading latest report...';
  await loadLatestReport();
  $('#progress').innerHTML = '';
}

// --- Health check ---
async function checkHealth() {
  const el = $('#ollamaStatus');
  try {
    const res = await fetch('/api/health');
    const data = await res.json();
    if (data.ok) {
      el.textContent = `Ollama OK (${data.models.length} models)`;
      el.className = 'status ok';
    } else {
      el.textContent = `Ollama: ${data.error}`;
      el.className = 'status fail';
    }
  } catch {
    el.textContent = 'Server unreachable';
    el.className = 'status fail';
  }
}

// --- Pages (tree-based) ---
let allPages = [...DEFAULT_PAGES.map(p => ({ ...p, depth: 0, status: 0, links: 0 }))];
let isDiscovering = false;

function renderPageTree() {
  const tree = $('#pageTree');
  tree.innerHTML = '';

  // Group pages by first path segment
  const groups = {};
  const ungrouped = [];

  for (const page of allPages) {
    const segments = page.path.split('/').filter(Boolean);
    if (segments.length > 1) {
      const groupKey = '/' + segments[0] + '/';
      if (!groups[groupKey]) groups[groupKey] = [];
      groups[groupKey].push(page);
    } else {
      ungrouped.push(page);
    }
  }

  // Render ungrouped pages first (root-level like /, /login.php)
  for (const page of ungrouped) {
    tree.appendChild(createPageItem(page, true));
  }

  // Render groups
  const sortedGroups = Object.entries(groups).sort(([a], [b]) => a.localeCompare(b));
  for (const [groupKey, pages] of sortedGroups) {
    const group = document.createElement('div');
    group.className = 'page-group';
    group.dataset.group = groupKey;

    const header = document.createElement('div');
    header.className = 'page-group-header';
    header.innerHTML = `
      <span class="arrow open">&#9654;</span>
      <input type="checkbox" checked data-group-toggle="${escAttr(groupKey)}">
      <span>${escHtml(groupKey)}</span>
      <span class="group-count">(${pages.length})</span>
    `;

    const items = document.createElement('div');
    items.className = 'page-group-items open';

    for (const page of pages) {
      items.appendChild(createPageItem(page, false));
    }

    // Toggle collapse
    header.addEventListener('click', (e) => {
      if (e.target.type === 'checkbox') return;
      header.querySelector('.arrow').classList.toggle('open');
      items.classList.toggle('open');
    });

    // Group checkbox toggles all children
    const groupCb = header.querySelector('input[type="checkbox"]');
    groupCb.addEventListener('change', () => {
      items.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = groupCb.checked;
      });
      updatePageCount();
    });

    group.appendChild(header);
    group.appendChild(items);
    tree.appendChild(group);
  }

  applyPageFilters();
}

function createPageItem(page, ungrouped) {
  const div = document.createElement('div');
  div.className = 'page-item' + (ungrouped ? ' ungrouped' : '');
  div.dataset.path = page.path;
  div.dataset.name = page.name;
  div.dataset.status = page.status || 0;

  let statusBadge = '';
  if (page.status > 0) {
    const cls = page.status < 300 ? 'ok' : page.status < 400 ? 'redirect' : 'error';
    statusBadge = `<span class="status-code ${cls}">${page.status}</span>`;
  }

  const existing = pageActions.get(page.path);
  const actionsBadge = existing?.length ? `<span class="actions-badge">${existing.length} action${existing.length > 1 ? 's' : ''}</span>` : '';

  div.innerHTML = `
    <div class="page-item-row">
      <input type="checkbox" checked data-path="${escAttr(page.path)}" data-name="${escAttr(page.name)}">
      <span>${escHtml(page.name)}</span>
      <span class="path">${escHtml(page.path)}</span>
      ${statusBadge}
      ${actionsBadge}
      <a class="actions-toggle" href="#">actions</a>
    </div>
    <div class="actions-editor">
      <label>Pre-screenshot actions (JSON array):</label>
      <textarea placeholder='[{ "click": ".btn" }, { "wait": ".modal" }]'>${existing ? JSON.stringify(existing, null, 2) : ''}</textarea>
      <div class="actions-hint">Types: click, fill (+value), hover, wait, select (+value), press, delay, waitForNavigation</div>
      <div class="actions-error"></div>
    </div>
  `;

  div.querySelector('input').addEventListener('change', updatePageCount);

  const toggle = div.querySelector('.actions-toggle');
  const editor = div.querySelector('.actions-editor');
  toggle.addEventListener('click', (e) => {
    e.preventDefault();
    editor.classList.toggle('open');
  });

  const textarea = div.querySelector('textarea');
  const errorEl = div.querySelector('.actions-error');
  textarea.addEventListener('change', () => {
    const text = textarea.value.trim();
    errorEl.textContent = '';
    if (!text) {
      pageActions.delete(page.path);
      const badge = div.querySelector('.actions-badge');
      if (badge) badge.remove();
      return;
    }
    try {
      const parsed = JSON.parse(text);
      if (!Array.isArray(parsed)) throw new Error('Must be a JSON array');
      pageActions.set(page.path, parsed);
      let badge = div.querySelector('.actions-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'actions-badge';
        div.querySelector('.path').after(badge);
      }
      badge.textContent = `${parsed.length} action${parsed.length > 1 ? 's' : ''}`;
      errorEl.textContent = '';
    } catch (err) {
      errorEl.textContent = err.message;
      pageActions.delete(page.path);
    }
  });

  return div;
}

function updatePageCount() {
  const all = $$('#pageTree input[type="checkbox"][data-path]');
  const visible = $$('#pageTree .page-item:not(.hidden) input[type="checkbox"][data-path]');
  const checked = $$('#pageTree .page-item:not(.hidden) input[type="checkbox"][data-path]:checked');
  const suffix = visible.length < all.length ? ` (${all.length} total)` : '';
  $('#pageCount').textContent = `${checked.length} of ${visible.length} selected${suffix}`;
}

// Combined search + status filter
function applyPageFilters() {
  const query = $('#pageSearch').value.toLowerCase();
  const statusFilter = $('#statusFilter').value;

  $$('#pageTree .page-item').forEach(item => {
    const name = (item.dataset.name || '').toLowerCase();
    const path = (item.dataset.path || '').toLowerCase();
    const status = parseInt(item.dataset.status || '0', 10);

    // Text search match
    const textMatch = !query || name.includes(query) || path.includes(query);

    // Status filter match
    let statusMatch = true;
    if (statusFilter === 'ok') statusMatch = status >= 200 && status < 300;
    else if (statusFilter === 'non-error') statusMatch = status > 0 && status < 400;
    else if (statusFilter === 'error') statusMatch = status >= 400;

    item.classList.toggle('hidden', !(textMatch && statusMatch));
  });

  // Show groups that have visible children
  $$('#pageTree .page-group').forEach(group => {
    const visibleItems = group.querySelectorAll('.page-item:not(.hidden)');
    group.style.display = visibleItems.length > 0 ? '' : 'none';
  });

  updatePageCount();
}

$('#pageSearch').addEventListener('input', applyPageFilters);
$('#statusFilter').addEventListener('change', () => {
  applyPageFilters();
  // Auto-deselect hidden items and select visible ones when filter changes
  $$('#pageTree .page-item').forEach(item => {
    const cb = item.querySelector('input[type="checkbox"]');
    if (cb) cb.checked = !item.classList.contains('hidden');
  });
  // Update group checkboxes
  $$('#pageTree .page-group').forEach(group => {
    const groupCb = group.querySelector('[data-group-toggle]');
    const childCbs = group.querySelectorAll('.page-group-items input[type="checkbox"]');
    if (groupCb && childCbs.length) {
      groupCb.checked = [...childCbs].some(cb => cb.checked);
    }
  });
  updatePageCount();
});

// Select all / none (only affects visible items)
$('#selectAll').addEventListener('click', () => {
  $$('#pageTree .page-item:not(.hidden) input[type="checkbox"]').forEach(cb => cb.checked = true);
  $$('#pageTree [data-group-toggle]').forEach(cb => cb.checked = true);
  updatePageCount();
});
$('#selectNone').addEventListener('click', () => {
  $$('#pageTree input[type="checkbox"]').forEach(cb => cb.checked = false);
  updatePageCount();
});

// Add custom page
$('#addCustom').addEventListener('click', () => {
  const input = $('#customPath');
  let path = input.value.trim();
  if (!path) return;
  if (!path.startsWith('/')) path = '/' + path;
  const name = path.replace(/^\//, '').replace(/\.\w+$/, '').replace(/[_-]/g, ' ') || 'custom';
  allPages.push({ name: name.charAt(0).toUpperCase() + name.slice(1), path, depth: 0, status: 0, links: 0 });
  renderPageTree();
  input.value = '';
});

// Discover pages
$('#discoverBtn').addEventListener('click', startDiscovery);

async function startDiscovery() {
  if (isDiscovering) return;
  isDiscovering = true;

  const btn = $('#discoverBtn');
  const statusEl = $('#discoverStatus');
  btn.disabled = true;
  btn.textContent = 'Discovering...';

  const baseUrl = $('#baseUrl').value.trim();
  const maxPages = parseInt($('#pageCap').value, 10);
  const allowPrivate = $('#allowPrivate').checked;

  if (!baseUrl) {
    statusEl.textContent = 'Enter a base URL first';
    btn.disabled = false;
    btn.textContent = 'Discover Pages';
    isDiscovering = false;
    return;
  }

  // Clear existing pages and start fresh
  allPages = [];
  renderPageTree();

  try {
    const response = await fetch('/api/discover', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify((() => {
        const b = { baseUrl, maxPages, allowPrivate, authState: currentAuthState };
        if (!currentAuthState) {
          const loginUrl = $('#loginUrl').value.trim();
          const username = $('#authUser').value.trim();
          const password = $('#authPass').value;
          if (loginUrl && username && password) b.credentials = { loginUrl, username, password };
        }
        return b;
      })()),
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        let msg;
        try { msg = JSON.parse(line.slice(6)); } catch { continue; }

        if (msg.event === 'discover-progress') {
          statusEl.innerHTML = `<span class="spinner" style="display:inline-block;width:12px;height:12px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 0.8s linear infinite;margin-right:6px;vertical-align:middle;"></span>${escHtml(msg.message)}`;
        } else if (msg.event === 'discover-page') {
          allPages.push(msg.page);
          renderPageTree();
        } else if (msg.event === 'discover-complete') {
          statusEl.textContent = `Found ${msg.total} pages via ${msg.source}` +
            (msg.pagesSkipped > 0 ? ` (${msg.pagesSkipped} skipped, cap reached)` : '');
        } else if (msg.event === 'discover-error') {
          statusEl.textContent = `Discovery error: ${msg.message}`;
        } else if (msg.event === 'auth-ready') {
          currentAuthState = msg.storageState;
          $('#authIndicator').textContent = 'authenticated';
          $('#authIndicator').className = 'auth-status ok';
          $('#authStatus').textContent = `Auto-login: ${msg.cookies} cookie${msg.cookies !== 1 ? 's' : ''}`;
          $('#authStatus').className = 'auth-status ok';
        }
      }
    }
  } catch (err) {
    statusEl.textContent = `Discovery failed: ${err.message}`;
  }

  btn.disabled = false;
  btn.textContent = 'Discover Pages';
  isDiscovering = false;
}

// --- Viewports ---
function renderViewports() {
  const bar = $('#viewportBar');
  bar.innerHTML = '';
  for (const [name, dims] of Object.entries(VIEWPORTS)) {
    const div = document.createElement('div');
    div.className = 'vp-item';
    const checked = name === 'desktop' || name === 'mobile' ? 'checked' : '';
    div.innerHTML = `
      <input type="checkbox" ${checked} data-viewport="${name}">
      <span>${name}</span>
      <span class="vp-dims">${dims.width}x${dims.height}</span>
    `;
    bar.appendChild(div);
  }
}

// --- Authentication ---
let currentAuthState = null;

$('#authToggle').addEventListener('click', () => {
  $('#authArrow').classList.toggle('open');
  $('#authBody').classList.toggle('open');
});

$('#authTestBtn').addEventListener('click', testLogin);
$('#authClearBtn').addEventListener('click', clearAuth);
$('#storageStateFile').addEventListener('change', loadStorageState);

async function testLogin() {
  const btn = $('#authTestBtn');
  const statusEl = $('#authStatus');
  const baseUrl = $('#baseUrl').value.trim();
  const loginUrl = $('#loginUrl').value.trim();
  const username = $('#authUser').value.trim();
  const password = $('#authPass').value;
  const allowPrivate = $('#allowPrivate').checked;

  if (!baseUrl || !loginUrl || !username || !password) {
    statusEl.textContent = 'Fill in all fields';
    statusEl.className = 'auth-status fail';
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Testing...';
  statusEl.textContent = '';

  try {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ baseUrl, loginUrl, username, password, allowPrivate }),
    });
    const data = await res.json();

    if (data.ok) {
      currentAuthState = data.storageState;
      statusEl.textContent = `Logged in (${data.cookies} cookies, redirected to ${data.redirectedTo})`;
      statusEl.className = 'auth-status ok';
      $('#authIndicator').textContent = 'authenticated';
      $('#authIndicator').className = 'auth-status ok';
    } else {
      statusEl.textContent = data.error || 'Login failed';
      statusEl.className = 'auth-status fail';
    }
  } catch (err) {
    statusEl.textContent = `Error: ${err.message}`;
    statusEl.className = 'auth-status fail';
  }

  btn.disabled = false;
  btn.textContent = 'Test Login';
}

function clearAuth() {
  currentAuthState = null;
  $('#authStatus').textContent = 'Auth cleared';
  $('#authStatus').className = 'auth-status';
  $('#authIndicator').textContent = '';
  $('#authUser').value = '';
  $('#authPass').value = '';
  $('#storageStateFile').value = '';
}

async function loadStorageState(e) {
  const file = e.target.files[0];
  if (!file) return;

  try {
    const text = await file.text();
    const state = JSON.parse(text);
    if (!state.cookies && !state.origins) {
      throw new Error('Invalid storageState: missing cookies or origins');
    }
    currentAuthState = state;
    $('#authStatus').textContent = `Loaded ${file.name} (${(state.cookies || []).length} cookies)`;
    $('#authStatus').className = 'auth-status ok';
    $('#authIndicator').textContent = 'authenticated';
    $('#authIndicator').className = 'auth-status ok';
  } catch (err) {
    $('#authStatus').textContent = `Invalid file: ${err.message}`;
    $('#authStatus').className = 'auth-status fail';
  }
}

// --- Saved Environments (server API + localStorage fallback) ---
function getDefaultEnvironments() {
  return [
    { name: 'Localhost', url: 'http://localhost:8081' },
  ];
}

async function loadEnvironments() {
  try {
    const res = await fetch('/api/environments');
    if (res.ok) {
      const envs = await res.json();
      if (Array.isArray(envs) && envs.length > 0) {
        localStorage.setItem(STORAGE_KEY_ENVS, JSON.stringify(envs));
        return envs;
      }
    }
  } catch {}
  // Fallback to localStorage
  try {
    const stored = localStorage.getItem(STORAGE_KEY_ENVS);
    if (stored) {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed) && parsed.length > 0) return parsed;
    }
  } catch {}
  return getDefaultEnvironments();
}

async function saveEnvironments(envs) {
  localStorage.setItem(STORAGE_KEY_ENVS, JSON.stringify(envs));
  // Sync each environment to server
  for (const env of envs) {
    try {
      await fetch(`/api/environments/${encodeURIComponent(env.name)}/state`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(env),
      });
    } catch {}
  }
}

async function deleteEnvironment(name) {
  try {
    await fetch(`/api/environments/${encodeURIComponent(name)}`, { method: 'DELETE' });
  } catch {}
}

async function renderEnvironments() {
  const bar = $('#envBar');
  const urlInput = $('#baseUrl');

  // Remove existing buttons (keep the url input)
  bar.querySelectorAll('.env-btn, .env-add-btn').forEach(el => el.remove());

  const envs = await loadEnvironments();

  envs.forEach((env, idx) => {
    const btn = document.createElement('button');
    btn.className = 'env-btn' + (urlInput.value === env.url ? ' active' : '');
    btn.dataset.url = env.url;
    btn.dataset.idx = idx;
    btn.innerHTML = `${escHtml(env.name)}<span class="remove-env" title="Remove">&times;</span>`;

    btn.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-env')) return;
      bar.querySelectorAll('.env-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      urlInput.value = env.url;
      try {
        const hostname = new URL(env.url).hostname;
        $('#allowPrivate').checked = ['localhost', '127.0.0.1', '::1'].includes(hostname);
      } catch {}
    });

    btn.addEventListener('dblclick', async () => {
      const newName = prompt('Environment name:', env.name);
      if (newName === null) return;
      const newUrl = prompt('URL:', env.url);
      if (newUrl === null) return;
      const oldName = env.name;
      const envs = await loadEnvironments();
      envs[idx] = { name: newName.trim() || env.name, url: newUrl.trim() };
      if (oldName !== newName.trim()) await deleteEnvironment(oldName);
      await saveEnvironments(envs);
      await renderEnvironments();
    });

    btn.querySelector('.remove-env').addEventListener('click', async (e) => {
      e.stopPropagation();
      const removedName = env.name;
      const envs = await loadEnvironments();
      envs.splice(idx, 1);
      await deleteEnvironment(removedName);
      await saveEnvironments(envs);
      await renderEnvironments();
    });

    bar.insertBefore(btn, urlInput);
  });

  // Add button
  const addBtn = document.createElement('button');
  addBtn.className = 'env-add-btn';
  addBtn.textContent = '+ Add';
  addBtn.addEventListener('click', async () => {
    const name = prompt('Environment name (e.g. "Staging", "Production"):');
    if (!name) return;
    const url = prompt('URL:', 'https://');
    if (!url) return;
    const envs = await loadEnvironments();
    envs.push({ name: name.trim(), url: url.trim() });
    await saveEnvironments(envs);
    await renderEnvironments();
    // Select the new one
    $('#baseUrl').value = url.trim();
    bar.querySelectorAll('.env-btn').forEach(b => b.classList.remove('active'));
    const last = bar.querySelectorAll('.env-btn');
    if (last.length) last[last.length - 1].classList.add('active');
  });
  bar.insertBefore(addBtn, urlInput);
}

// --- Report persistence ---
async function loadLatestReport() {
  try {
    const res = await fetch('/api/reports');
    const reports = await res.json();
    if (reports.length > 0) {
      await loadReportById(reports[0].id);
    }
  } catch { /* no reports yet */ }
}

async function loadReportById(id) {
  try {
    const res = await fetch(`/api/reports/${id}`);
    if (!res.ok) return;
    const report = await res.json();
    currentReportId = report.id;
    currentResults = report.results || {};

    // Render results
    renderFullReport(report);
    updateReportInfo(report);
    updateResumeButton(report);
    updateExportButton();
  } catch { /* failed to load */ }
}

function renderFullReport(report) {
  const resultsEl = $('#results');
  resultsEl.innerHTML = '';

  const totals = { critical: 0, warning: 0, suggestion: 0 };

  // Render results in order of pages × viewports
  for (const page of (report.pages || [])) {
    const viewports = report.config?.viewports || ['desktop'];
    for (const vp of viewports) {
      const key = `${page.name}::${vp}`;
      if (report.results[key]) {
        const result = report.results[key];
        renderResultCard({ page: page.name, viewport: vp, data: result, cached: true }, resultsEl);
        for (const issue of (result.issues || [])) {
          totals[issue.severity] = (totals[issue.severity] || 0) + 1;
        }
      } else if (report.errors && report.errors[key]) {
        renderErrorCard({ page: page.name, viewport: vp, message: report.errors[key].message }, resultsEl);
      }
    }
  }

  if (Object.keys(report.results || {}).length > 0) {
    updateSummaryBadges(totals);
  }
}

function updateReportInfo(report) {
  const infoEl = $('#reportInfo');
  infoEl.style.display = 'flex';

  $('#reportId').textContent = report.id;

  const statusEl = $('#reportStatus');
  statusEl.textContent = report.status;
  statusEl.className = `report-status ${report.status}`;

  const completed = Object.keys(report.results || {}).length;
  const total = report.totalExpected || 0;
  $('#reportProgress').textContent = `${completed}/${total} pages`;

  if (report.updatedAt) {
    const d = new Date(report.updatedAt);
    $('#reportTime').textContent = d.toLocaleString();
  }
}

function updateResumeButton(report) {
  const btn = $('#resumeBtn');
  const completed = Object.keys(report.results || {}).length;
  const total = report.totalExpected || 0;
  const hasErrors = Object.keys(report.errors || {}).length > 0;

  if ((completed < total || hasErrors) && report.status !== 'running') {
    const remaining = total - completed;
    btn.style.display = '';
    btn.textContent = `Resume (${remaining} remaining)`;
  } else {
    btn.style.display = 'none';
  }
}

function updateExportButton() {
  const btn = $('#exportBtn');
  btn.style.display = Object.keys(currentResults).length > 0 ? '' : 'none';
}

// --- History ---
$('#historyToggle').addEventListener('click', async () => {
  const panel = $('#historyPanel');
  if (panel.classList.contains('open')) {
    panel.classList.remove('open');
    return;
  }

  try {
    const res = await fetch('/api/reports');
    const reports = await res.json();
    const list = $('#historyList');
    list.innerHTML = '';

    if (reports.length === 0) {
      list.innerHTML = '<div class="empty" style="padding:12px">No reports yet.</div>';
    }

    for (const r of reports) {
      const div = document.createElement('div');
      div.className = 'history-item';
      const d = new Date(r.createdAt);
      const statusClass = r.status || '';
      div.innerHTML = `
        <span class="hi-date">${d.toLocaleString()}</span>
        <span class="hi-url">${escHtml(r.baseUrl || '')}</span>
        <span class="hi-progress">${r.resultCount}/${r.totalExpected}</span>
        <span class="report-status ${statusClass}" style="font-size:11px">${r.status}</span>
      `;
      div.addEventListener('click', () => {
        panel.classList.remove('open');
        loadReportById(r.id);
      });
      list.appendChild(div);
    }

    panel.classList.add('open');
  } catch {}
});

// --- Run / Resume / Export ---
function setupActions() {
  $('#runBtn').addEventListener('click', () => startReview(false));
  $('#resumeBtn').addEventListener('click', () => startReview(true));
  $('#pauseBtn').addEventListener('click', pauseReview);
  $('#stopBtn').addEventListener('click', stopReview);
  $('#exportBtn').addEventListener('click', exportReport);

  // Watch mode controls
  $('#rerunBtn').addEventListener('click', rerunWatch);
  $('#stopWatchBtn').addEventListener('click', stopWatch);
}

/** Re-trigger a review on the active watch session. */
async function rerunWatch() {
  if (!currentWatchReportId) return;
  const btn = $('#rerunBtn');
  btn.disabled = true;
  btn.textContent = 'Re-reviewing...';
  const watchStatus = $('#watchPanel').querySelector('.watch-status');
  watchStatus.innerHTML = '<span class="dot" style="background:var(--accent)"></span> Re-reviewing...';

  try {
    const progressEl = $('#progress');
    const resultsEl = $('#results');
    resultsEl.innerHTML = '';
    const totals = { critical: 0, warning: 0, suggestion: 0 };

    const body = {
      reportId: currentWatchReportId,
      baseUrl: $('#baseUrl')?.value || '',
      pages: [],
      viewports: getSelectedViewports(),
      allowPrivate: $('#allowPrivate').checked,
      authState: currentAuthState,
    };

    const response = await fetch('/api/review', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        let msg;
        try { msg = JSON.parse(line.slice(6)); } catch { continue; }

        if (msg.event === 'progress') {
          progressEl.innerHTML = `<span class="spinner"></span>${escHtml(msg.message)}`;
        } else if (msg.event === 'result') {
          const key = `${msg.page}::${msg.viewport}`;
          currentResults[key] = msg.data;
          renderResultCard(msg, resultsEl);
          for (const issue of (msg.data?.issues || [])) {
            totals[issue.severity] = (totals[issue.severity] || 0) + 1;
          }
          updateSummaryBadges(totals);
        } else if (msg.event === 'page-error') {
          renderErrorCard(msg, resultsEl);
        } else if (msg.event === 'done') {
          progressEl.innerHTML = '';
        }
      }
    }
  } catch (err) {
    $('#progress').innerHTML = `<span style="color:var(--critical)">Re-review failed: ${escHtml(err.message)}</span>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Re-review';
    const watchStatus = $('#watchPanel').querySelector('.watch-status');
    watchStatus.innerHTML = '<span class="dot"></span> Watching';
  }
}

/** Stop the active watch session. */
async function stopWatch() {
  if (!currentWatchReportId) return;
  try {
    await fetch(`/api/watch/${currentWatchReportId}/stop`, { method: 'POST' });
  } catch {}
  currentWatchReportId = null;
  $('#watchPanel').style.display = 'none';
}

function setReviewButtons(state) {
  const runBtn = $('#runBtn');
  const pauseBtn = $('#pauseBtn');
  const stopBtn = $('#stopBtn');
  const resumeBtn = $('#resumeBtn');

  if (state === 'running') {
    runBtn.style.display = 'none';
    pauseBtn.style.display = '';
    stopBtn.style.display = '';
    resumeBtn.style.display = 'none';
  } else if (state === 'paused') {
    runBtn.style.display = 'none';
    pauseBtn.style.display = 'none';
    stopBtn.style.display = 'none';
    resumeBtn.style.display = '';
    resumeBtn.textContent = 'Resume';
  } else {
    runBtn.style.display = '';
    runBtn.disabled = false;
    runBtn.textContent = 'Run Review';
    pauseBtn.style.display = 'none';
    stopBtn.style.display = 'none';
    // Resume visibility managed by updateResumeButton
  }
}

function pauseReview() {
  if (!currentReviewController) return;
  reviewWasPaused = true;
  currentReviewController.abort();
}

function stopReview() {
  if (!currentReviewController) return;
  reviewWasPaused = false;
  currentReviewController.abort();
}

function getSelectedPages() {
  const pages = [];
  $$('#pageTree input[type="checkbox"][data-path]:checked').forEach(cb => {
    const page = { name: cb.dataset.name, path: cb.dataset.path };
    const actions = pageActions.get(cb.dataset.path);
    if (actions && actions.length > 0) page.actions = actions;
    pages.push(page);
  });
  return pages;
}

function getSelectedViewports() {
  const vps = [];
  $$('#viewportBar input[type="checkbox"]:checked').forEach(cb => {
    vps.push(cb.dataset.viewport);
  });
  return vps;
}

// --- Export ---
function exportReport() {
  if (Object.keys(currentResults).length === 0) return;

  const allIssues = [];
  for (const [key, result] of Object.entries(currentResults)) {
    if (result._raw) continue;
    const [page, viewport] = key.split('::');
    for (const issue of (result.issues || [])) {
      allIssues.push({ ...issue, page, viewport });
    }
  }

  // Group by severity
  const bySeverity = { critical: [], warning: [], suggestion: [] };
  for (const issue of allIssues) {
    (bySeverity[issue.severity] || []).push(issue);
  }

  const date = new Date().toISOString().split('T')[0];
  const baseUrl = $('#baseUrl').value.trim();
  let md = `# UI Review Report\n\n`;
  md += `**URL:** ${baseUrl}\n`;
  md += `**Date:** ${date}\n`;
  md += `**Report ID:** ${currentReportId || 'N/A'}\n`;
  md += `**Total Issues:** ${allIssues.length}`;
  if (bySeverity.critical.length) md += ` | ${bySeverity.critical.length} critical`;
  if (bySeverity.warning.length) md += ` | ${bySeverity.warning.length} warning`;
  if (bySeverity.suggestion.length) md += ` | ${bySeverity.suggestion.length} suggestion`;
  md += `\n\n---\n\n`;

  // Summaries per page
  const pageKeys = [...new Set(Object.keys(currentResults).map(k => k.split('::')[0]))];
  md += `## Page Summaries\n\n`;
  for (const pageName of pageKeys) {
    const pageResults = Object.entries(currentResults).filter(([k]) => k.startsWith(pageName + '::'));
    for (const [key, result] of pageResults) {
      const vp = key.split('::')[1];
      if (result.summary && !result._raw) {
        md += `- **${pageName}** (${vp}): ${result.summary}\n`;
      }
    }
  }
  md += `\n`;

  // Screenshots listing
  const screenshotRefs = [];
  for (const [key, result] of Object.entries(currentResults)) {
    if (result.screenshot) {
      const [page, viewport] = key.split('::');
      screenshotRefs.push({ page, viewport, path: result.screenshot });
    }
  }

  for (const [severity, label] of [['critical', 'Critical'], ['warning', 'Warning'], ['suggestion', 'Suggestion']]) {
    const issues = bySeverity[severity];
    if (!issues.length) continue;

    md += `## ${label} (${issues.length})\n\n`;

    for (const issue of issues) {
      md += `- [ ] **[${issue.page} - ${issue.viewport}]** ${issue.description}\n`;
      if (issue.location) md += `  - Location: ${issue.location}\n`;
      if (issue.category) md += `  - Category: ${issue.category}\n`;
      if (issue.recommendation) md += `  - Fix: ${issue.recommendation}\n`;
    }
    md += `\n`;
  }

  if (screenshotRefs.length > 0) {
    md += `## Screenshots\n\n`;
    md += `Screenshots saved in report directory: \`reports/${currentReportId}/screenshots/\`\n\n`;
    for (const ref of screenshotRefs) {
      md += `- **${ref.page}** (${ref.viewport}): \`${ref.path}\`\n`;
    }
    md += `\n`;
  }

  // Count raw results
  const rawCount = Object.values(currentResults).filter(r => r._raw).length;
  if (rawCount > 0) {
    md += `## Unparsed Results (${rawCount})\n\n`;
    md += `${rawCount} page/viewport combinations returned unstructured text that could not be converted to issues. Re-run these pages for structured results.\n\n`;
  }

  md += `---\n*Generated by [ui-review](https://github.com/Zyrtnin/ui-review)*\n`;

  // Download as .md file
  const blob = new Blob([md], { type: 'text/markdown' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `ui-review-${date}-${currentReportId || 'report'}.md`;
  a.click();
  URL.revokeObjectURL(a.href);
}

async function startReview(resume) {
  const baseUrl = $('#baseUrl').value.trim();
  const pages = getSelectedPages();
  const viewports = getSelectedViewports();
  const allowPrivate = $('#allowPrivate').checked;

  if (!baseUrl) return alert('Enter a base URL');
  if (!pages.length) return alert('Select at least one page');
  if (!viewports.length) return alert('Select at least one viewport');

  const progressEl = $('#progress');
  const resultsEl = $('#results');

  // Set up abort controller for pause/stop
  currentReviewController = new AbortController();
  reviewWasPaused = false;
  setReviewButtons('running');

  // For fresh runs, clear results. For resume, keep existing.
  if (!resume) {
    resultsEl.innerHTML = '';
    currentReportId = null;
    currentResults = {};
  }

  const totals = { critical: 0, warning: 0, suggestion: 0 };

  // Recount existing results if resuming
  if (resume) {
    for (const r of Object.values(currentResults)) {
      for (const issue of (r.issues || [])) {
        totals[issue.severity] = (totals[issue.severity] || 0) + 1;
      }
    }
    updateSummaryBadges(totals);
  }

  const watchMode = $('#watchMode').checked;
  const pollInterval = watchMode ? parseInt($('#pollSelect').value, 10) || 0 : 0;
  const body = { baseUrl, pages, viewports, allowPrivate, watchMode, pollInterval, authState: currentAuthState };

  // Auto-auth: if credentials filled but not yet authenticated, send them
  if (!currentAuthState) {
    const loginUrl = $('#loginUrl').value.trim();
    const username = $('#authUser').value.trim();
    const password = $('#authPass').value;
    if (loginUrl && username && password) {
      body.credentials = { loginUrl, username, password };
    }
  }
  if (resume && currentReportId) {
    body.reportId = currentReportId;
    // skipCompleted is built server-side from existing results
  }

  // Hide watch panel from any previous session
  $('#watchPanel').style.display = 'none';
  currentWatchReportId = null;

  let wasAborted = false;

  try {
    const response = await fetch('/api/review', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal: currentReviewController.signal,
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        let msg;
        try { msg = JSON.parse(line.slice(6)); } catch { continue; }

        if (msg.event === 'report-id') {
          currentReportId = msg.reportId;
        } else if (msg.event === 'progress') {
          progressEl.innerHTML = `<span class="spinner"></span>${escHtml(msg.message)}`;
        } else if (msg.event === 'result') {
          const key = `${msg.page}::${msg.viewport}`;

          // Remove existing card for this key if re-rendering on resume
          if (msg.cached && resume) {
            // Don't re-render cached results that are already shown
            if (currentResults[key]) continue;
          }

          currentResults[key] = msg.data;
          renderResultCard(msg, resultsEl);
          for (const issue of (msg.data?.issues || [])) {
            totals[issue.severity] = (totals[issue.severity] || 0) + 1;
          }
          updateSummaryBadges(totals);
        } else if (msg.event === 'page-error') {
          renderErrorCard(msg, resultsEl);
        } else if (msg.event === 'error') {
          progressEl.innerHTML = '';
          renderErrorCard({ page: 'System', message: msg.message }, resultsEl);
        } else if (msg.event === 'auth-ready') {
          // Server performed auto-login — cache the auth state
          currentAuthState = msg.storageState;
          $('#authIndicator').textContent = 'authenticated';
          $('#authIndicator').className = 'auth-status ok';
          $('#authStatus').textContent = `Auto-login: ${msg.cookies} cookie${msg.cookies !== 1 ? 's' : ''}`;
          $('#authStatus').className = 'auth-status ok';
        } else if (msg.event === 'watch-ready') {
          // Show watch mode controls
          $('#watchPanel').style.display = '';
          currentWatchReportId = msg.reportId;
        } else if (msg.event === 'done') {
          progressEl.innerHTML = '';
          // Refresh report info
          if (currentReportId) {
            try {
              const res = await fetch(`/api/reports/${currentReportId}`);
              const report = await res.json();
              updateReportInfo(report);
              updateResumeButton(report);
              updateExportButton();
            } catch {}
          }
        }
      }
    }
  } catch (err) {
    if (err.name === 'AbortError') {
      wasAborted = true;
      progressEl.innerHTML = reviewWasPaused
        ? '<span style="color:var(--warning)">Review paused — click Resume to continue</span>'
        : '<span style="color:var(--text-dim)">Review stopped</span>';
    } else {
      progressEl.innerHTML = '';
      renderErrorCard({ page: 'Network', message: err.message }, resultsEl);
    }
  }

  currentReviewController = null;
  setReviewButtons(reviewWasPaused ? 'paused' : 'idle');

  // After abort, refresh report info to get accurate status and show Resume button
  if (wasAborted && currentReportId) {
    // Give server a moment to finalize the report
    await new Promise(r => setTimeout(r, 300));
    try {
      const res = await fetch(`/api/reports/${currentReportId}`);
      const report = await res.json();
      updateReportInfo(report);
      updateResumeButton(report);
      updateExportButton();
    } catch {}
  }

  if (!resultsEl.children.length) {
    resultsEl.innerHTML = '<div class="empty">No results. Check your configuration and try again.</div>';
  }
}

// --- Rendering ---
function renderResultCard(msg, container) {
  const card = document.createElement('div');
  card.className = 'result-card' + (msg.cached ? ' cached' : '');

  let data = msg.data || {};

  // Client-side fallback: if server returned _raw, try to re-parse
  if (data._raw && data.summary) {
    try {
      const parsed = JSON.parse(data.summary);
      if (Array.isArray(parsed.issues)) {
        data = { ...parsed, _raw: false, url: data.url, viewport: data.viewport };
      }
    } catch {
      const m = data.summary.match(/\{[\s\S]*\}/);
      if (m) {
        try {
          const parsed = JSON.parse(m[0]);
          if (Array.isArray(parsed.issues)) {
            data = { ...parsed, _raw: false, url: data.url, viewport: data.viewport };
          }
        } catch { /* give up */ }
      }
    }
  }

  const issues = Array.isArray(data.issues) ? data.issues : [];
  const counts = { critical: 0, warning: 0, suggestion: 0 };
  issues.forEach(i => { if (i.severity) counts[i.severity]++; });

  const badges = Object.entries(counts)
    .filter(([, n]) => n > 0)
    .map(([sev, n]) => `<span class="badge ${sev}">${n} ${sev}</span>`)
    .join('');

  const isRaw = !!data._raw;

  const summary = (data.summary && !isRaw && !data.summary.startsWith('{'))
    ? `<div class="summary-text">${escHtml(data.summary)}</div>`
    : '';

  const cachedTag = msg.cached ? '<span class="cached-tag">cached</span>' : '';
  const rawTag = isRaw ? '<span class="badge warning" style="font-size:10px">raw</span>' : '';

  // For raw responses, show the actual VLM text (truncated for readability)
  let rawContent = '';
  if (isRaw && data.summary) {
    const rawText = typeof data.summary === 'string' ? data.summary : JSON.stringify(data.summary, null, 2);
    rawContent = `
      <div style="color:var(--warning);font-size:12px;padding:4px 0;margin-bottom:8px;">VLM returned unstructured text (not parsed as JSON):</div>
      <pre style="font-size:12px;color:var(--text-dim);background:var(--surface);padding:10px;border-radius:6px;white-space:pre-wrap;word-break:break-word;max-height:400px;overflow-y:auto;line-height:1.6;">${escHtml(rawText)}</pre>
    `;
  }

  // Build screenshot panel if available
  const screenshotUrl = data.screenshot && currentReportId
    ? `/api/reports/${currentReportId}/${data.screenshot}`
    : null;
  const screenshotPanel = screenshotUrl
    ? `<div class="screenshot-panel">
        <img src="${escAttr(screenshotUrl)}" alt="Screenshot of ${escAttr(msg.page)}" loading="lazy"
             onclick="document.getElementById('screenshotOverlayImg').src=this.src; document.getElementById('screenshotOverlay').classList.add('open'); document.body.style.overflow='hidden';">
       </div>`
    : '';

  // Build issues panel content
  const issuesContent = `
    ${summary}
    ${issues.map(renderIssue).join('')}
    ${!isRaw && issues.length === 0 ? '<div style="color:var(--success);font-size:13px;padding:8px 0;">No issues found!</div>' : ''}
    ${rawContent}
  `;

  card.innerHTML = `
    <div class="result-card-header" onclick="this.querySelector('.arrow').classList.toggle('open'); this.nextElementSibling.classList.toggle('open')">
      <span class="arrow">&#9654;</span>
      <span class="page-name">${escHtml(msg.page)} <span style="color:var(--text-dim);font-size:12px">(${escHtml(msg.viewport)})</span></span>
      ${cachedTag}
      ${rawTag}
      <span class="issue-count">${isRaw ? 'parse failed' : issues.length + ' issue' + (issues.length !== 1 ? 's' : '')}</span>
      ${badges}
    </div>
    <div class="result-card-body">
      <div class="result-card-content">
        ${screenshotPanel}
        <div class="issues-panel">
          ${issuesContent}
        </div>
      </div>
    </div>
  `;
  container.appendChild(card);
}

function renderIssue(issue) {
  return `
    <div class="issue">
      <div class="issue-header">
        <span class="badge ${issue.severity}">${issue.severity}</span>
        <span class="category">${escHtml(issue.category)}</span>
      </div>
      <div class="location">${escHtml(issue.location)}</div>
      <div class="description">${escHtml(issue.description)}</div>
      ${issue.recommendation ? `<div class="recommendation">${escHtml(issue.recommendation)}</div>` : ''}
    </div>
  `;
}

function renderErrorCard(msg, container) {
  const card = document.createElement('div');
  card.className = 'error-card';
  card.textContent = `${msg.page || 'Error'}${msg.viewport ? ` (${msg.viewport})` : ''}: ${msg.message}`;
  container.appendChild(card);
}

function updateSummaryBadges(totals) {
  let header = $('#resultsSummary');
  if (!header) {
    header = document.createElement('div');
    header.className = 'results-header';
    header.id = 'resultsSummary';
    const resultsEl = $('#results');
    resultsEl.insertBefore(header, resultsEl.firstChild);
  }
  const total = totals.critical + totals.warning + totals.suggestion;
  header.innerHTML = `
    <h2 style="font-size:14px;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-dim)">Results</h2>
    <div class="summary-badges">
      <span style="font-size:13px;color:var(--text-dim)">${total} total</span>
      ${totals.critical ? `<span class="badge critical">${totals.critical} critical</span>` : ''}
      ${totals.warning ? `<span class="badge warning">${totals.warning} warning</span>` : ''}
      ${totals.suggestion ? `<span class="badge suggestion">${totals.suggestion} suggestion</span>` : ''}
    </div>
  `;
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}

function escAttr(s) {
  return (s || '').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Close screenshot overlay on Escape
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.getElementById('screenshotOverlay').classList.remove('open');
    document.body.style.overflow = '';
  }
});

init();
</script>
</body>
</html>
